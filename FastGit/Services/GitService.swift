//
//  GitService.swift
//  FastGit
//
//  Created by FastGit Team
//

import Foundation
import SwiftGitX
import libgit2

extension Array where Element == String {
    /// ‰∏¥Êó∂Â∞ÜÂ≠óÁ¨¶‰∏≤Êï∞ÁªÑËΩ¨Êç¢‰∏∫ C `git_strarray` Âπ∂Âú®Èó≠ÂåÖÂÜÖ‰ΩøÁî®„ÄÇ
    /// Ëá™Âä®Â§ÑÁêÜÂÜÖÂ≠òÂàÜÈÖçÂíåÈáäÊîæ„ÄÇ
    func withGitStrArray<R>(_ body: (inout git_strarray) throws -> R) throws -> R {
        let cStrings = self.map { strdup($0) }
        defer {
            for ptr in cStrings { free(ptr) }
        }

        var strArray = git_strarray()
        return try cStrings.withUnsafeBufferPointer { buffer in
            strArray.strings = UnsafeMutablePointer(mutating: buffer.baseAddress)
            strArray.count = self.count
            return try body(&strArray)
        }
    }
}

// --- Êñ∞Â¢û: ËæÖÂä©Êâ©Â±ï‰ª•Êö¥Èú≤‰∏Ä‰∏™ÂäüËÉΩÊõ¥Âº∫Â§ßÁöÑ fetch Âíå push ÊñπÊ≥ï ---
fileprivate extension Repository {
//    func push(remote: Remote, refspecs: [String]) async throws {
//        try await withUnsafeThrowingContinuation { (continuation: UnsafeContinuation<Void, Error>) in
//            do {
//                let mirror = Mirror(reflecting: self)
//                guard let repoPointer = mirror.descendant("pointer") as? OpaquePointer else {
//                    throw GitServiceError.operationFailed("Could not get repository pointer via reflection.")
//                }
//
//                var remotePointer: OpaquePointer?
//                defer { git_remote_free(remotePointer) }
//                let remoteLookupStatus = git_remote_lookup(&remotePointer, repoPointer, remote.name)
//                guard remoteLookupStatus == GIT_OK.rawValue else {
//                    throw RepositoryError.failedToPush("Remote '\(remote.name)' not found.")
//                }
//
//                var cStrings = refspecs.map { str in UnsafeMutablePointer(mutating: (str as NSString).utf8String) }
//                var gitStrArray = git_strarray(strings: &cStrings, count: refspecs.count)
//
//                DispatchQueue.global(qos: .userInitiated).async {
//                    let pushStatus = git_remote_push(remotePointer, &gitStrArray, nil)
//                    
//                    if pushStatus == GIT_OK.rawValue {
//                        continuation.resume()
//                    } else {
//                        let errorMessage = String(cString: git_error_last().pointee.message)
//                        continuation.resume(throwing: RepositoryError.failedToPush(errorMessage))
//                    }
//                }
//            } catch {
//                continuation.resume(throwing: error)
//            }
//        }
//    }
    
    // MARK: - Fetch Operation

    /// ‰ªéÊåáÂÆöÁöÑËøúÁ®ã‰ªìÂ∫ìÊäìÂèñÂØπË±°ÂíåÂºïÁî®ÔºåÂπ∂Êèê‰æõËØ¶ÁªÜÁöÑÈÖçÁΩÆÈÄâÈ°π„ÄÇ
    ///
    /// Ëøô‰∏™ÊñπÊ≥ïÊòØ `git fetch` ÂëΩ‰ª§ÁöÑÂº∫Â§ßÂ∞ÅË£ÖÔºåÂÖÅËÆ∏‰Ω†Á≤æÁªÜÊéßÂà∂ÊäìÂèñËøáÁ®ã„ÄÇ
    ///
    /// - Parameters:
    ///   - remoteName: Ë¶ÅÊäìÂèñÁöÑËøúÁ®ã‰ªìÂ∫ìÁöÑÂêçÁß∞ (‰æãÂ¶Ç, "origin")„ÄÇ
    ///   - refspecs: ‰∏Ä‰∏™ÂèØÈÄâÁöÑ refspec Â≠óÁ¨¶‰∏≤Êï∞ÁªÑ (‰æãÂ¶Ç, ["refs/heads/main:refs/remotes/origin/main"])„ÄÇ
    ///               Â¶ÇÊûú‰∏∫ `nil`ÔºåÂ∞Ü‰ΩøÁî®ËøúÁ®ã‰ªìÂ∫ìÁöÑÈªòËÆ§ÈÖçÁΩÆ„ÄÇ
    ///   - options: ‰∏Ä‰∏™ `FetchOptions` ÂÆû‰æãÔºåÁî®‰∫éÈÖçÁΩÆÊäìÂèñË°å‰∏∫ÔºåÂ¶Ç `prune` Âíå `downloadTags`„ÄÇ
    /// - Throws: Â¶ÇÊûúÊäìÂèñÊìç‰ΩúÂ§±Ë¥•Ôºå‰ºöÊäõÂá∫ `RepositoryError.failedToFetch` ÈîôËØØ„ÄÇ
    func fetch(remote remoteName: String, refspecs: [String]? = nil, options: FetchOptions = .default) async throws {
        // ÂÅáËÆæ self.pointer ÂèØ‰ª•Áõ¥Êé•ËÆøÈóÆÂ∫ïÂ±ÇÁöÑ C ÊåáÈíà
        let repoPointer = self.pointer

        var remotePointer: OpaquePointer?
        defer { git_remote_free(remotePointer) }
        guard git_remote_lookup(&remotePointer, repoPointer, remoteName) == GIT_OK.rawValue, remotePointer != nil else {
            throw RepositoryError.failedToFetch("Êâæ‰∏çÂà∞Âêç‰∏∫ '\(remoteName)' ÁöÑËøúÁ®ã‰ªìÂ∫ì„ÄÇ")
        }

        var gitFetchOptions = options.toGitFetchOptions()

        let status: Int32
        if let refspecs = refspecs, !refspecs.isEmpty {
            // ‰ΩøÁî®ËæÖÂä©ÂáΩÊï∞Ôºå‰ª£Á†ÅÈùûÂ∏∏Âπ≤ÂáÄ
            status = try refspecs.withGitStrArray { gitStrArray in
                git_remote_fetch(remotePointer, &gitStrArray, &gitFetchOptions, nil)
            }
        } else {
            status = git_remote_fetch(remotePointer, nil, &gitFetchOptions, nil)
        }

        if status != GIT_OK.rawValue {
            let errorMessage = String(cString: git_error_last().pointee.message)
            throw RepositoryError.failedToFetch(errorMessage)
        }
        
        // Ê≥®ÊÑèÔºö`withUnsafeThrowingContinuation` Âíå `DispatchQueue` ÁöÑÈÉ®ÂàÜË¢´ÁúÅÁï•‰∫Ü
        // Âõ†‰∏∫ËøôÈáåÁöÑÈáçÁÇπÊòØ C ‰∫íÊìç‰ΩúÁöÑÈÄªËæë„ÄÇ‰Ω†Â∫îËØ•Â∞ÜËøôÊÆµÈÄªËæëÂåÖË£ÖÂú®‰πãÂâçÁöÑÂºÇÊ≠•ÁªìÊûÑ‰∏≠„ÄÇ
    }

//    func pull(options: PullOptions) async throws {
//        let mirror = Mirror(reflecting: self)
//        guard let repoPointer = mirror.descendant("pointer") as? OpaquePointer else {
//            throw GitServiceError.operationFailed("Could not get repository pointer.")
//        }
//        
//        // Âú®ÊâßË°åÊìç‰ΩúÂâçÔºåÁ°Æ‰øù‰ªìÂ∫ìÊúâÂèØÁî®ÁöÑÁ≠æÂêç
//        try self.ensureRepositorySignature()
//
//        // 1. Handle uncommitted changes (Stash)
//        var stashed = false
//        if options.uncommittedChangesOption == .stash {
//            let status = try self.status()
//            if !status.isEmpty {
//                _ = try self.stash.save(message: "Auto-stash before pull")
//                stashed = true
//                print("üóÑÔ∏è Stashed changes before pull.")
//            }
//        }
//        
//        do {
//            // 2. Fetch
//            guard let remote = self.remote[options.selectedRemote] else {
//                throw RepositoryError.failedToFetch("Remote '\(options.selectedRemote)' not found.")
//            }
//            print("‚¨áÔ∏è Fetching from remote '\(remote.name)'...")
//            let fetchOptionsVal = FetchOptions(remote: options.selectedRemote, prune: true, fetchAllTags: true)
//            try await self.fetch(remote: remote, options: fetchOptionsVal)
//            
//            // 3. Merge Analysis and Fast-Forward
//            var fetchHeadOid = git_oid()
//            let fetchHeadStatus = git_repository_fetchhead_foreach(repoPointer, { (_, _, oid, _, payload) -> Int32 in
//                if let oid = oid {
//                    git_oid_cpy(payload?.assumingMemoryBound(to: git_oid.self), oid)
//                    return -1 // Stop iteration after finding the first one
//                }
//                return 0
//            }, &fetchHeadOid)
//
//            guard fetchHeadStatus == GIT_ITEROVER.rawValue else {
//                 throw GitServiceError.operationFailed("Could not find FETCH_HEAD. The remote branch may be empty or you are already up-to-date.")
//            }
//
//            var annotatedCommit: OpaquePointer?
//            defer { git_annotated_commit_free(annotatedCommit) }
//            let annotatedLookupStatus = git_annotated_commit_lookup(&annotatedCommit, repoPointer, &fetchHeadOid)
//            guard annotatedLookupStatus == GIT_OK.rawValue, annotatedCommit != nil else {
//                 throw GitServiceError.operationFailed("Could not look up fetched commit.")
//            }
//
//            var analysis: git_merge_analysis_t = GIT_MERGE_ANALYSIS_NONE
//            var preference: git_merge_preference_t = GIT_MERGE_PREFERENCE_NONE
//            
//            var theirHeads: [OpaquePointer?] = [annotatedCommit]
//            
//            let analysisStatus = git_merge_analysis(&analysis, &preference, repoPointer, &theirHeads, 1)
//            guard analysisStatus == GIT_OK.rawValue else {
//                throw GitServiceError.operationFailed("Merge analysis failed.")
//            }
//
//            if (analysis.rawValue & GIT_MERGE_ANALYSIS_UP_TO_DATE.rawValue) != 0 {
//                print("‚úÖ Already up-to-date.")
//            } else if (analysis.rawValue & GIT_MERGE_ANALYSIS_FASTFORWARD.rawValue) != 0 || (analysis.rawValue & GIT_MERGE_ANALYSIS_UNBORN.rawValue) != 0 {
//                print("üèÉ Performing fast-forward merge...")
//
//                guard let targetOid = git_annotated_commit_id(annotatedCommit) else {
//                    throw GitServiceError.operationFailed("Could not get target OID for fast-forward.")
//                }
//                
//                var localRef: OpaquePointer?
//                defer { git_reference_free(localRef) }
//                let headFullName = try self.HEAD.fullName
//                let lookupStatus = git_reference_lookup(&localRef, repoPointer, headFullName)
//                guard lookupStatus == GIT_OK.rawValue, localRef != nil else {
//                    throw GitServiceError.operationFailed("Could not lookup local branch reference: \(headFullName).")
//                }
//                
//                var newRef: OpaquePointer?
//                defer { git_reference_free(newRef) }
//                let setTargetStatus = git_reference_set_target(&newRef, localRef, targetOid, "pull: Fast-forward")
//                guard setTargetStatus == GIT_OK.rawValue else {
//                    let err = String(cString: git_error_last().pointee.message)
//                    throw GitServiceError.operationFailed("Could not set target for fast-forward merge: \(err)")
//                }
//
//                var checkoutOpts = git_checkout_options()
//                git_checkout_options_init(&checkoutOpts, UInt32(GIT_CHECKOUT_OPTIONS_VERSION))
//                checkoutOpts.checkout_strategy = GIT_CHECKOUT_FORCE.rawValue
//                let checkoutStatus = git_checkout_head(repoPointer, &checkoutOpts)
//                guard checkoutStatus == GIT_OK.rawValue else {
//                    throw GitServiceError.operationFailed("Could not checkout HEAD after fast-forward merge.")
//                }
//            } else {
//                throw GitServiceError.operationFailed("Your local branch has diverged from the remote branch. A merge or rebase is required, which is not yet fully implemented.")
//            }
//
//        } catch {
//            if stashed {
//                print(" Popping stash after failed pull...")
//                try? self.stash.pop()
//            }
//            throw error
//        }
//        
//        if stashed {
//            print(" Popping stash after successful pull...")
//            try? self.stash.pop()
//        }
//    }
    
    /// Á°Æ‰øù‰ªìÂ∫ìÊúâÂèØÁî®ÁöÑÁ≠æÂêçÔºåÂ¶ÇÊûúÊ≤°ÊúâÔºåÂàô‰ªéÂ∫îÁî®ËÆæÁΩÆ‰∏≠Ê≥®ÂÖ•
    func ensureRepositorySignature() throws {
        // 1. Ê£ÄÊü•‰ªìÂ∫ìÁöÑÊú¨Âú∞ÈÖçÁΩÆÊòØÂê¶Â∑≤ÁªèÊúâÁ≠æÂêç
        if self.config.string(forKey: "user.name") != nil, self.config.string(forKey: "user.email") != nil {
            return // Êú¨Âú∞ÈÖçÁΩÆÂ∑≤Â≠òÂú®ÔºåÊó†ÈúÄÊìç‰Ωú
        }
        
        // 2. Â¶ÇÊûúÊú¨Âú∞Ê≤°ÊúâÔºå‰ªé UserDefaults (Â∫îÁî®ÂÜÖ‚ÄúÂÖ®Â±Ä‚ÄùËÆæÁΩÆ) Ëé∑Âèñ
        guard let name = UserDefaults.standard.string(forKey: "globalUserName"), !name.isEmpty,
              let email = UserDefaults.standard.string(forKey: "globalUserEmail"), !email.isEmpty else {
            // 3. Â¶ÇÊûúÂ∫îÁî®ÂÜÖËÆæÁΩÆ‰πüÊ≤°ÊúâÔºåÂàôÊäõÂá∫ÈîôËØØÔºåÊèêÁ§∫Áî®Êà∑ÂéªËÆæÁΩÆ
            throw GitServiceError.signatureNotFound
        }
        
        // 4. Â∞ÜÂ∫îÁî®ÂÜÖËÆæÁΩÆÁöÑÁ≠æÂêçÂÜôÂÖ•Âà∞‰ªìÂ∫ìÁöÑÊú¨Âú∞ .git/config Êñá‰ª∂‰∏≠
        self.config.set(name, forKey: "user.name")
        self.config.set(email, forKey: "user.email")
        print("‚úçÔ∏è Â∑≤Â∞ÜÂ∫îÁî®ÂÜÖÈÖçÁΩÆÁöÑÁ≠æÂêçÊ≥®ÂÖ•Âà∞‰ªìÂ∫ìÊú¨Âú∞ÈÖçÁΩÆ‰∏≠„ÄÇ")
    }
}


/// GitÊúçÂä°Á±ª - ‰∏éSwiftGitX‰∫§‰∫íÁöÑÂîØ‰∏ÄÂÖ•Âè£
@MainActor
class GitService: ObservableObject {
    
    // MARK: - Âçï‰æã
    static let shared = GitService()
    
    // MARK: - Â±ûÊÄß
    @Published var currentRepository: GitRepository?
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    // SwiftGitXÂàùÂßãÂåñÁä∂ÊÄÅ
    private var isSwiftGitXInitialized = false
    
    private init() {
        // ÂàùÂßãÂåñSwiftGitX
        initializeSwiftGitX()
    }
    
    deinit {
        // Ê∏ÖÁêÜSwiftGitXËµÑÊ∫ê
        if isSwiftGitXInitialized {
            do {
                try SwiftGitX.shutdown()
                print("‚úÖ SwiftGitX Â∑≤Âú®deinit‰∏≠ÂÖ≥Èó≠")
            } catch {
                print("‚ö†Ô∏è SwiftGitX ÂÖ≥Èó≠Â§±Ë¥•: \(error)")
            }
            isSwiftGitXInitialized = false
        }
    }
    
    // MARK: - SwiftGitX ÁÆ°ÁêÜ
    
    /// ÂàùÂßãÂåñSwiftGitX
    private func initializeSwiftGitX() {
        guard !isSwiftGitXInitialized else { return }
        
        do {
            try SwiftGitX.initialize()
            isSwiftGitXInitialized = true
        } catch {
            print("‚ùå SwiftGitX ÂàùÂßãÂåñÂ§±Ë¥•: \(error)")
        }
    }
    
    /// ÂÖ≥Èó≠SwiftGitX
    private func shutdownSwiftGitX() {
        guard isSwiftGitXInitialized else { return }
        
        do {
            try SwiftGitX.shutdown()
            isSwiftGitXInitialized = false
            print("‚úÖ SwiftGitX Â∑≤ÂÖ≥Èó≠")
        } catch {
            print("‚ö†Ô∏è SwiftGitX ÂÖ≥Èó≠Â§±Ë¥•: \(error)")
            isSwiftGitXInitialized = false
        }
    }
    
    // MARK: - ‰ªìÂ∫ìÊìç‰Ωú
    
    /// ÊâìÂºÄÊú¨Âú∞‰ªìÂ∫ì
    /// - Parameter path: ‰ªìÂ∫ìË∑ØÂæÑ
    /// - Returns: ÊâìÂºÄÁöÑ‰ªìÂ∫ìÂØπË±°ÔºåÂ¶ÇÊûúÂ§±Ë¥•ËøîÂõûnil
    func openRepository(at path: String) async -> GitRepository? {
        isLoading = true
        errorMessage = nil
        
        do {
            // Ê£ÄÊü•Ë∑ØÂæÑÊòØÂê¶Â≠òÂú®
            let repoURL = URL(fileURLWithPath: path)
            guard FileManager.default.fileExists(atPath: path) else {
                throw GitServiceError.repositoryNotFound(path: path)
            }
            
            // Ê£ÄÊü•ÊòØÂê¶ÊòØGit‰ªìÂ∫ì
            let gitPath = repoURL.appendingPathComponent(".git").path
            guard FileManager.default.fileExists(atPath: gitPath) else {
                throw GitServiceError.notAGitRepository(path: path)
            }
            
            // ‰ΩøÁî®SwiftGitXÊâìÂºÄ‰ªìÂ∫ì
            let _ = try Repository.open(at: repoURL)
            
            // ÂàõÂª∫Êàë‰ª¨ÁöÑGitRepositoryÂØπË±°
            let repoName = repoURL.lastPathComponent
            let repository = GitRepository(name: repoName, path: path)
            
            currentRepository = repository
            isLoading = false
            
            print("‚úÖ ÊàêÂäüÊâìÂºÄ‰ªìÂ∫ì: \(repository.displayName) at \(path)")
            return repository
            
        } catch {
            let errorMsg = "ÊâìÂºÄ‰ªìÂ∫ìÂ§±Ë¥•: \(error.localizedDescription)"
            errorMessage = errorMsg
            isLoading = false
            print("‚ùå \(errorMsg)")
            return nil
        }
    }
    
    /// Ëé∑ÂèñÊèê‰∫§ÂéÜÂè≤
    /// - Parameter repository: ÁõÆÊ†á‰ªìÂ∫ì
    /// - Parameter startingFromSha: ÂèØÈÄâÁöÑËµ∑ÂßãÊèê‰∫§SHAÔºåÁî®‰∫é‰ªéÁâπÂÆöÁÇπÂºÄÂßãÂä†ËΩΩÂéÜÂè≤
    /// - Returns: ÂåÖÂê´Êèê‰∫§„ÄÅÂàÜÊîØÂíåÊ†áÁ≠æÁöÑÂÖÉÁªÑ
    func fetchCommitHistory(for repository: GitRepository, startingFromSha: String? = nil) async -> (commits: [GitCommit], branches: [GitBranch], tags: [GitTag]) {
        isLoading = true
        errorMessage = nil
        
        do {
            // ‰ΩøÁî®SwiftGitXËé∑ÂèñÁúüÂÆûÁöÑÊèê‰∫§ÂéÜÂè≤
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            
            print("üîç ‰ªìÂ∫ìË∞ÉËØï‰ø°ÊÅØ:")
            print("   - ‰ªìÂ∫ìË∑ØÂæÑ: \(repository.path)")
            print("   - ÊòØÂê¶‰∏∫Á©∫: \(swiftGitXRepo.isEmpty)")
            print("   - HEADÊòØÂê¶Êú™ÁîüÊàê: \(swiftGitXRepo.isHEADUnborn)")
            print("   - HEADÊòØÂê¶ÂàÜÁ¶ª: \(swiftGitXRepo.isHEADDetached)")
            print("   - ÊòØÂê¶‰∏∫bare‰ªìÂ∫ì: \(swiftGitXRepo.isBare)")
            
            // Ê£ÄÊü•‰ªìÂ∫ìÊòØÂê¶‰∏∫Á©∫ÊàñHEADÊú™ÁîüÊàê
            if swiftGitXRepo.isEmpty {
                print("‚ö†Ô∏è ‰ªìÂ∫ì‰∏∫Á©∫ÔºåÊ≤°ÊúâÊèê‰∫§ÂéÜÂè≤")
                isLoading = false
                return ([], [], [])
            }
            
            if swiftGitXRepo.isHEADUnborn {
                print("‚ö†Ô∏è ‰ªìÂ∫ìHEADÊú™ÁîüÊàêÔºåÂèØËÉΩÊòØÂàöÂàõÂª∫ÁöÑÁ©∫‰ªìÂ∫ì")
                isLoading = false
                return ([], [], [])
            }
            
            // Ëé∑ÂèñÊâÄÊúâÂàÜÊîØÂíåÊ†áÁ≠æ‰ø°ÊÅØ
            let branches = try await fetchBranches(from: swiftGitXRepo)
            let tags = try await fetchTags(from: swiftGitXRepo)
            
            // ÂàõÂª∫ SHA -> ÂàÜÊîØÂêçÂíå SHA -> Ê†áÁ≠æÂêçÁöÑÊò†Â∞Ñ
            let branchMap = createCommitReferencesMap(branches: branches)
            let tagMap = createCommitReferencesMap(tags: tags)
            
            print("üöÄ ÂºÄÂßãËé∑ÂèñÊèê‰∫§ÂéÜÂè≤... (Ëµ∑ÁÇπ: \(startingFromSha ?? "HEAD"))")
            let commitSequence: CommitSequence
            if let startSha = startingFromSha {
                let oid = try OID(hex: startSha)
                let startCommit: Commit = try swiftGitXRepo.show(id: oid)
                commitSequence = swiftGitXRepo.log(from: startCommit)
            } else {
                commitSequence = try swiftGitXRepo.log()
            }
            
            var commits: [GitCommit] = []
            
            // ‰ΩøÁî®CommitSequenceËø≠‰ª£Âô®Ëé∑ÂèñÊèê‰∫§ÂéÜÂè≤
            for swiftGitXCommit in commitSequence {
                let author = GitAuthor(name: swiftGitXCommit.author.name, email: swiftGitXCommit.author.email)
                let parentShas: [String]
                do {
                    parentShas = try swiftGitXCommit.parents.map { $0.id.hex }
                } catch {
                    print("‚ö†Ô∏è Ëé∑ÂèñÁà∂Êèê‰∫§Â§±Ë¥•: \(error)")
                    parentShas = []
                }
                
                let commitSha = swiftGitXCommit.id.hex
                let commitBranches = branchMap[commitSha] ?? []
                let commitTags = tagMap[commitSha] ?? []
                
                let fastGitCommit = GitCommit(
                    sha: commitSha,
                    message: swiftGitXCommit.message,
                    author: author,
                    date: swiftGitXCommit.date,
                    parents: parentShas,
                    branches: commitBranches,
                    tags: commitTags
                )
                commits.append(fastGitCommit)
                
                // ÈôêÂà∂Ëé∑ÂèñÊï∞ÈáèÈò≤Ê≠¢Âç°Ê≠ª
                if commits.count >= AppConfig.Git.maxCommitsToLoad { break }
            }
            
            isLoading = false
            
            return (commits, branches, tags)
            
        } catch {
            // ‰∏∫‰∏çÂêåÁ±ªÂûãÁöÑÈîôËØØÊèê‰æõÊõ¥ÂèãÂ•ΩÁöÑÈîôËØØ‰ø°ÊÅØ
            let errorMsg: String
            
            if let repoError = error as? RepositoryError {
                switch repoError {
                case .unbornHEAD:
                    errorMsg = "‰ªìÂ∫ìHEADÊú™ÂàùÂßãÂåñÔºöËøôÂèØËÉΩÊòØ‰∏Ä‰∏™Êñ∞ÂàõÂª∫ÁöÑÁ©∫‰ªìÂ∫ìÊàñ‰ªìÂ∫ìÊçüÂùè„ÄÇ"
                case .failedToGetHEAD(let message):
                    errorMsg = "Êó†Ê≥ïËØªÂèñGit‰ªìÂ∫ìHEAD: \(message)"
                default:
                    errorMsg = "‰ªìÂ∫ìÊìç‰ΩúÂ§±Ë¥•: \(error.localizedDescription)"
                }
            } else if error.localizedDescription.contains("Operation not permitted") {
                errorMsg = "ÊùÉÈôê‰∏çË∂≥ÔºöÊó†Ê≥ïËÆøÈóÆGit‰ªìÂ∫ìÊñá‰ª∂„ÄÇËØ∑Á°Æ‰øùÂ∫îÁî®ÊúâË∂≥Â§üÁöÑÊñá‰ª∂ËÆøÈóÆÊùÉÈôê„ÄÇ"
            } else {
                errorMsg = "Ëé∑ÂèñÊèê‰∫§ÂéÜÂè≤Â§±Ë¥•: \(error.localizedDescription)"
            }
            
            errorMessage = errorMsg
            isLoading = false
            print("‚ùå \(errorMsg)")
            print("‚ùå ËØ¶ÁªÜÈîôËØØ: \(error)")
            return ([], [], [])
        }
    }
    
    /// Ëé∑Âèñ‰ªìÂ∫ìÁöÑÊâÄÊúâÂ≠êÊ®°Âùó
    /// - Parameter repository: ÁõÆÊ†á‰ªìÂ∫ì
    /// - Returns: Â≠êÊ®°ÂùóÁõ∏ÂØπË∑ØÂæÑÁöÑÊï∞ÁªÑ
    func fetchSubmodules(for repository: GitRepository) async -> [String] {
        print("üì¶ ÂºÄÂßãËé∑ÂèñÂ≠êÊ®°Âùó...")
        var submodulePaths: [String] = []

        let callback: git_submodule_cb = { submodule, name, payload in
            guard let submodule = submodule,
                  let payload = payload else { return -1 }
            
            let submodulePathsPointer = payload.assumingMemoryBound(to: [String].self)
            
            if let pathPointer = git_submodule_path(submodule) {
                let path = String(cString: pathPointer)
                submodulePathsPointer.pointee.append(path)
            }
            
            return 0
        }

        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            
            let mirror = Mirror(reflecting: swiftGitXRepo)
            if let repoPointer = mirror.descendant("pointer") as? OpaquePointer {
                
                let status = withUnsafeMutablePointer(to: &submodulePaths) { payloadPointer in
                    git_submodule_foreach(repoPointer, callback, payloadPointer)
                }

                if status == GIT_OK.rawValue {
                    print("‚úÖ ÊàêÂäüËé∑ÂèñÂà∞ \(submodulePaths.count) ‰∏™Â≠êÊ®°Âùó„ÄÇ")
                } else {
                    let errorMessage = String(cString: git_error_last().pointee.message)
                    print("‚ùå Ë∞ÉÁî® git_submodule_foreach Â§±Ë¥•: \(errorMessage)")
                }
            } else {
                 print("‚ùå Êó†Ê≥ïÈÄöËøáÂèçÂ∞ÑËé∑Âèñ repository pointer„ÄÇ")
            }

        } catch {
            print("‚ùå ÊâìÂºÄ‰ªìÂ∫ì‰ª•Ëé∑ÂèñÂ≠êÊ®°ÂùóÊó∂Â§±Ë¥•: \(error.localizedDescription)")
        }
        
        return submodulePaths
    }
    
    /// Ëé∑Âèñ‰ªìÂ∫ìÁöÑÊâÄÊúâÂàÜÊîØ
    /// - Parameter repo: SwiftGitX ‰ªìÂ∫ìÂØπË±°
    /// - Returns: ÂàÜÊîØÊï∞ÁªÑ
    private func fetchBranches(from repo: Repository) async throws -> [GitBranch] {
        var branches: [GitBranch] = []

        print("üîç [ËØäÊñ≠] ÂºÄÂßãÊâßË°å fetchBranches...")
        do {
            let remotes = try repo.remote.list()
            if remotes.isEmpty {
                print("‚ö†Ô∏è [ËØäÊñ≠] Âú®‰ªìÂ∫ìÈÖçÁΩÆ‰∏≠Êú™ÊâæÂà∞‰ªª‰ΩïËøúÁ®ã‰ªìÂ∫ì„ÄÇËøôÂæàÂèØËÉΩÊòØÈóÆÈ¢òÁöÑÊ†πÊ∫ê„ÄÇ")
            } else {
                let remoteNames = remotes.compactMap { $0.name }
                print("‚úÖ [ËØäÊñ≠] ÊâæÂà∞ \(remotes.count) ‰∏™ËøúÁ®ã‰ªìÂ∫ì: \(remoteNames)")
            }
        } catch {
            print("‚ùå [ËØäÊñ≠] ÂàóÂá∫ËøúÁ®ã‰ªìÂ∫ìÂ§±Ë¥•: \(error)")
        }

        let currentBranchName: String?
        do {
            let currentBranch = try repo.branch.current
            currentBranchName = currentBranch.name
            print("üåø ÂΩìÂâçÂàÜÊîØÊòØ: \(currentBranchName ?? "Êó†")")
        } catch {
            print("‚ö†Ô∏è Ëé∑ÂèñÂΩìÂâçÂàÜÊîØÂ§±Ë¥•: \(error)")
            currentBranchName = nil
        }
        
        do {
            let localBranches = try repo.branch.list(.local)
            print("üåø ÊâæÂà∞ \(localBranches.count) ‰∏™Êú¨Âú∞ÂàÜÊîØ„ÄÇ")
            for branch in localBranches {
                let isCurrent = branch.name == currentBranchName
                let fastGitBranch = GitBranch(
                    name: branch.name,
                    isCurrent: isCurrent,
                    isRemote: false,
                    targetSha: branch.target.id.hex
                )
                branches.append(fastGitBranch)
            }
        } catch {
            print("‚ö†Ô∏è Ëé∑ÂèñÊú¨Âú∞ÂàÜÊîØÂ§±Ë¥•: \(error)")
        }
        
        do {
            let remotes = try repo.remote.list()
            var remoteBranchCount = 0

            for remote in remotes {
                for remoteBranch in remote.branches {
                    let fastGitBranch = GitBranch(
                        name: remoteBranch.name,
                        isCurrent: false,
                        isRemote: true,
                        targetSha: remoteBranch.target.id.hex
                    )
                    branches.append(fastGitBranch)
                    remoteBranchCount += 1
                }
            }
            print("‚úÖ ÈÄöËøáÈÅçÂéÜ Remote ÂØπË±°ÔºåÊàêÂäüÊâæÂà∞ \(remoteBranchCount) ‰∏™ËøúÁ®ãÂàÜÊîØ„ÄÇ")
        } catch {
            print("‚ùå Ëé∑ÂèñËøúÁ®ãÂàÜÊîØÂàóË°®Â§±Ë¥•: \(error)")
        }
        
        print("üåø ÊÄªÂÖ±Ëé∑ÂèñÂà∞ \(branches.count) ‰∏™ÂàÜÊîØ„ÄÇ")
        return branches
    }
    
    /// Ëé∑Âèñ‰ªìÂ∫ìÁöÑÊâÄÊúâÊ†áÁ≠æ
    /// - Parameter repo: SwiftGitX ‰ªìÂ∫ìÂØπË±°
    /// - Returns: Ê†áÁ≠æÊï∞ÁªÑ
    private func fetchTags(from repo: Repository) async throws -> [GitTag] {
        var tags: [GitTag] = []
        
        do {
            let swiftGitXTags = try repo.tag.list()
            for swiftGitXTag in swiftGitXTags {
                let isAnnotated = swiftGitXTag.tagger != nil
                
                var message: String?
                var taggerName: String?
                var taggerEmail: String?
                var date: Date?
                
                if isAnnotated {
                    message = swiftGitXTag.message
                    taggerName = swiftGitXTag.tagger?.name
                    taggerEmail = swiftGitXTag.tagger?.email
                    date = swiftGitXTag.tagger?.date
                }
                
                let tag = GitTag(
                    name: swiftGitXTag.name,
                    targetSha: swiftGitXTag.target.id.hex,
                    message: message,
                    taggerName: taggerName,
                    taggerEmail: taggerEmail,
                    date: date,
                    isAnnotated: isAnnotated
                )
                tags.append(tag)
            }
        } catch {
            print("‚ö†Ô∏è Ëé∑ÂèñÊ†áÁ≠æÂ§±Ë¥•: \(error)")
        }
        
        print("üè∑Ô∏è Ëé∑ÂèñÂà∞ \(tags.count) ‰∏™Ê†áÁ≠æ")
        return tags
    }
    
    /// ÂàõÂª∫Êèê‰∫§SHAÂà∞ÂºïÁî®ÂêçÁß∞ÁöÑÊò†Â∞Ñ
    private func createCommitReferencesMap(branches: [GitBranch]) -> [String: [String]] {
        var map: [String: [String]] = [:]
        for branch in branches {
            if let sha = branch.targetSha {
                map[sha, default: []].append(branch.name)
            }
        }
        return map
    }
    
    /// ÂàõÂª∫Êèê‰∫§SHAÂà∞Ê†áÁ≠æÂêçÁß∞ÁöÑÊò†Â∞Ñ
    private func createCommitReferencesMap(tags: [GitTag]) -> [String: [String]] {
        var map: [String: [String]] = [:]
        for tag in tags {
            map[tag.targetSha, default: []].append(tag.name)
        }
        return map
    }

    /// Ëé∑ÂèñÊåáÂÆöÊèê‰∫§ÁöÑÂèòÊõ¥Êñá‰ª∂ÂàóË°®
    func fetchChanges(for commit: GitCommit, in repository: GitRepository) async -> [GitFileStatus] {
        print("üîç Fetching changes for commit: \(commit.shortSha)")
        var changes: [GitFileStatus] = []
        
        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            
            let oid = try OID(hex: commit.sha)
            let swiftGitXCommit: Commit = try swiftGitXRepo.show(id: oid)
            
            let diff = try swiftGitXRepo.diff(commit: swiftGitXCommit)
            
            for delta in diff.changes {
                let path = delta.newFile.path
                let statusType = convertStatus(from: delta.type)
                
                // We don't have line changes here, so default to 0
                let fileStatus = GitFileStatus(path: path, status: statusType, linesAdded: 0, linesDeleted: 0)
                changes.append(fileStatus)
            }
            
            print("‚úÖ Found \(changes.count) changes for commit \(commit.shortSha)")
            
        } catch {
            print("‚ùå Failed to fetch changes for commit \(commit.shortSha): \(error.localizedDescription)")
        }
        
        return changes
    }
    
    /// Ëé∑ÂèñÂΩìÂâç‰ªìÂ∫ìÁöÑÊñá‰ª∂Áä∂ÊÄÅ
    func fetchStatus(for repository: GitRepository) async -> [FileStatusItem] {
        var fileItems: [String: FileStatusItem] = [:]

        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)

            let statusOptions: StatusOption = [.includeUntracked, .includeIgnored]
            let statusEntries = try swiftGitXRepo.status(options: statusOptions)
            
            let stagedDiff = try swiftGitXRepo.diff(to: .index)
            let stagedPatchMap = Dictionary(uniqueKeysWithValues: stagedDiff.patches.map { ($0.delta.newFile.path, $0) })
            
            let workingTreeDiff = try swiftGitXRepo.diff(to: .workingTree)
            let workingTreePatchMap = Dictionary(uniqueKeysWithValues: workingTreeDiff.patches.map { ($0.delta.newFile.path, $0) })

            for entry in statusEntries {
                var path: String?
                var stagedChange: FileChange?
                var unstagedChange: FileChange?

                if let indexDelta = entry.index {
                    path = indexDelta.newFile.path
                    let (added, deleted) = calculateLineChanges(for: path, in: stagedPatchMap)
                    stagedChange = FileChange(
                        path: path!,
                        status: convertStatus(from: indexDelta.type),
                        linesAdded: added,
                        linesDeleted: deleted
                    )
                }
                
                if let workdirDelta = entry.workingTree {
                    path = workdirDelta.newFile.path
                    let (added, deleted) = calculateLineChanges(for: path, in: workingTreePatchMap)
                    unstagedChange = FileChange(
                        path: path!,
                        status: convertStatus(from: workdirDelta.type),
                        linesAdded: added,
                        linesDeleted: deleted
                    )
                }

                if let finalPath = entry.workingTree?.newFile.path ?? entry.index?.newFile.path {
                    if fileItems[finalPath] == nil {
                        fileItems[finalPath] = FileStatusItem(path: finalPath, stagedChange: nil, unstagedChange: nil)
                    }
                    if let sc = stagedChange {
                        fileItems[finalPath] = FileStatusItem(path: finalPath, stagedChange: sc, unstagedChange: fileItems[finalPath]?.unstagedChange)
                    }
                    if let uc = unstagedChange {
                        fileItems[finalPath] = FileStatusItem(path: finalPath, stagedChange: fileItems[finalPath]?.stagedChange, unstagedChange: uc)
                    }
                }
            }
        } catch {
            print("‚ùå Failed to fetch status: \(error.localizedDescription)")
        }
        
        return Array(fileItems.values).sorted { $0.path < $1.path }
    }
    
    // MARK: - ÂÖ®Â±Ä Git ÈÖçÁΩÆ
    
    /// Ëé∑Âèñ Git ÁâàÊú¨‰ø°ÊÅØ
    func getGitVersion() -> String {
        return SwiftGitX.libgit2Version
    }

    /// ÊâßË°å fetch Êìç‰Ωú
    func fetch(remote: String, with options: FetchOptions, in repository: GitRepository) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            
            print("Fetching from \(remote)...")
            try await swiftGitXRepo.fetch(remote: remote, options: options)
            print("‚úÖ Fetch successful for remote '\(remote)' in \(repository.displayName)")
        } catch {
            let errorMsg = "Fetch failed: \(error.localizedDescription)"
            errorMessage = errorMsg
            print("‚ùå \(errorMsg)")
        }
        
        isLoading = false
    }

    /// ÊâßË°å pull Êìç‰Ωú
    func pull(with options: PullOptions, in repository: GitRepository) async {
        isLoading = true
        errorMessage = nil
        
//        do {
//            let repoURL = URL(fileURLWithPath: repository.path)
//            let swiftGitXRepo = try Repository.open(at: repoURL)
//            
//            // ‰ΩøÁî®Êàë‰ª¨Ëá™ÂÆö‰πâÁöÑpullÊñπÊ≥ïÊù•Â§ÑÁêÜÈîÅÊñá‰ª∂ÈóÆÈ¢ò
//            try await swiftGitXRepo.pull(options: options)
//
//            print("‚úÖ Pull successful for repository \(repository.displayName)")
//        } catch {
//            let errorMsg = "Pull failed: \(error.localizedDescription)"
//            errorMessage = errorMsg
//            print("‚ùå \(errorMsg)")
//        }
        
        isLoading = false
    }

    /// ÂàõÂª∫Êñ∞ÂàÜÊîØ
    func createBranch(name: String, options: NewBranchOptions, in repository: GitRepository) async -> Bool {
        isLoading = true
        errorMessage = nil
        
        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            
            try swiftGitXRepo.ensureRepositorySignature()

            let statusItems = try swiftGitXRepo.status()
            if !statusItems.isEmpty {
                switch options.uncommittedChangesOption {
                case .stash:
                    _ = try swiftGitXRepo.stash.save(message: "Stash for creating branch \(name)")
                    print("‚úÖ Stashed uncommitted changes.")
                case .discard:
                    guard let headCommit = try swiftGitXRepo.HEAD.target as? Commit else {
                        throw GitServiceError.operationFailed("Could not get HEAD commit to discard changes.")
                    }
                    try swiftGitXRepo.reset(to: headCommit, mode: .hard)
                    print("‚úÖ Discarded uncommitted changes.")
                }
            }
            
            guard let baseBranchSha = options.baseBranch.targetSha,
                  let baseCommitOid = try? OID(hex: baseBranchSha) else {
                throw GitServiceError.operationFailed("Base branch has no valid target SHA.")
            }
            let baseCommit: Commit = try swiftGitXRepo.show(id: baseCommitOid)

            let newBranch = try swiftGitXRepo.branch.create(
                named: name,
                target: baseCommit,
                force: options.allowOverwrite
            )
            print("‚úÖ Successfully created branch '\(name)'")
            
            if options.checkoutAfterCreation {
                try swiftGitXRepo.switch(to: newBranch)
                print("‚úÖ Switched to new branch '\(name)'")
            }

            isLoading = false
            return true
            
        } catch {
            let errorMsg = "Failed to create branch: \(error.localizedDescription)"
            errorMessage = errorMsg
            print("‚ùå \(errorMsg)")
            isLoading = false
            return false
        }
    }
    
    /// ÊâßË°å Stash Êìç‰Ωú
    func stash(with options: StashOptions, in repository: GitRepository) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            
            try swiftGitXRepo.ensureRepositorySignature()
            
            var stashFlags: StashOption = .default
            if options.includeUntracked {
                stashFlags.insert(.includeUntracked)
            }
            
            _ = try swiftGitXRepo.stash.save(message: options.message, options: stashFlags)
            print("‚úÖ Stash successful")
            
        } catch {
            let errorMsg = "Stash failed: \(error.localizedDescription)"
            errorMessage = errorMsg
            print("‚ùå \(errorMsg)")
        }
        
        isLoading = false
    }
    
    /// ÊâßË°å Push Êìç‰Ωú
    func push(with options: PushOptions, in repository: GitRepository) async {
        isLoading = true
        errorMessage = nil
        
        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            
            try swiftGitXRepo.ensureRepositorySignature()
            
            guard let remote = swiftGitXRepo.remote[options.remote] else {
                throw GitServiceError.operationFailed("Remote '\(options.remote)' not found.")
            }
            
            let remoteBranchName = options.remoteBranch?.shortName ?? options.localBranch.shortName
            let localBranchRef = "refs/heads/\(options.localBranch.shortName)"
            let remoteBranchRef = "refs/heads/\(remoteBranchName)"
            
            var refspec = "\(localBranchRef):\(remoteBranchRef)"
            if options.forcePush {
                refspec = "+\(refspec)"
            }

//            try await swiftGitXRepo.push(remote: remote, refspecs: [refspec])
            try await swiftGitXRepo.push(remote: remote)
            
            print("‚úÖ Push successful to \(options.remote)/\(remoteBranchName)")

        } catch {
            let errorMsg = "Push failed: \(error.localizedDescription)"
            errorMessage = errorMsg
            print("‚ùå \(errorMsg)")
        }
        
        isLoading = false
    }
    
    /// Ëé∑ÂèñËøúÁ®ã‰ªìÂ∫ìÂàóË°®
    func listRemotes(for repository: GitRepository) async -> [String] {
        do {
            let repoURL = URL(fileURLWithPath: repository.path)
            let swiftGitXRepo = try Repository.open(at: repoURL)
            return try swiftGitXRepo.remote.list().compactMap { $0.name }
        } catch {
            print("‚ùå Failed to list remotes: \(error.localizedDescription)")
            return []
        }
    }

    private func calculateLineChanges(for path: String?, in patchMap: [String: Patch]) -> (added: Int, deleted: Int) {
        guard let path = path, let patch = patchMap[path] else {
            return (0, 0)
        }
        
        var linesAdded = 0
        var linesDeleted = 0
        
        for hunk in patch.hunks {
            for line in hunk.lines {
                if line.type == .addition {
                    linesAdded += 1
                } else if line.type == .deletion {
                    linesDeleted += 1
                }
            }
        }
        return (linesAdded, linesDeleted)
    }
    
    private func convertStatus(from deltaType: Diff.DeltaType) -> GitFileStatusType {
        switch deltaType {
        case .added: return .added
        case .deleted: return .deleted
        case .modified: return .modified
        case .renamed: return .renamed
        case .copied: return .copied
        case .untracked: return .untracked
        case .typeChange: return .typeChanged
        case .ignored: return .ignored
        case .conflicted: return .conflicted
        default: return .modified
        }
    }
}


// MARK: - ÈîôËØØÁ±ªÂûãÂÆö‰πâ
enum GitServiceError: LocalizedError {
    case repositoryNotFound(path: String)
    case notAGitRepository(path: String)
    case permissionDenied(path: String)
    case initializationFailed(String)
    case operationFailed(String)
    case signatureNotFound
    
    var errorDescription: String? {
        switch self {
        case .repositoryNotFound(let path):
            return "‰ªìÂ∫ìË∑ØÂæÑ‰∏çÂ≠òÂú®: \(path)"
        case .notAGitRepository(let path):
            return "‰∏çÊòØÊúâÊïàÁöÑGit‰ªìÂ∫ì: \(path)"
        case .permissionDenied(let path):
            return "ÊùÉÈôê‰∏çË∂≥ÔºöÊó†Ê≥ïËÆøÈóÆ \(path)„ÄÇËØ∑Ê£ÄÊü•Â∫îÁî®ÊùÉÈôêËÆæÁΩÆÊàñÈÄâÊã©ÂÖ∂‰ªñ‰ªìÂ∫ì„ÄÇ"
        case .initializationFailed(let message):
            return "ÂàùÂßãÂåñÂ§±Ë¥•: \(message)"
        case .operationFailed(let message):
            return "Êìç‰ΩúÂ§±Ë¥•: \(message)"
        case .signatureNotFound:
            return "GitÁ≠æÂêçÊú™ÊâæÂà∞„ÄÇËØ∑Âú®Â∫îÁî®ÁöÑËÆæÁΩÆÈ°µÈù¢‰∏≠ÈÖçÁΩÆÊÇ®ÁöÑ'Áî®Êà∑Âêç'Âíå'ÈÇÆÁÆ±'„ÄÇ"
        }
    }
}










